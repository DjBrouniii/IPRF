(* 3.1 Écrire une fonction récursive produit qui, sur la donnée d’une liste d’entiers, renvoie le produit de tous les éléments de cette liste.*)

(* 3.2 Écrire une fonction récursive carre_liste qui, sur la donnée d’une liste d’entiers l, renvoie la liste des carrés des éléments de l.*)

(* 3.3 Écrire une fonction récursive min_max qui, sur la donnée d’une liste d’entiers, renvoie le couple formé du plus petit et du plus grand entier dans cette liste.*)

(* note : Pour la liste vide, on pourra renvoyer (max_int, min_int). Pourquoi ?*)

(* 3.4 Écrire une fonction récursive recherche qui, sur la donnée d’un élément e et d’une liste l, renvoie true si e apparaît dans l, et false sinon.*)

(* 3.5 Écrire une fonction récursive nb_occurrence qui, sur la donnée d’un élément e et d’une liste l, renvoie le nombre de fois où e apparaît dans l.*)

(* 3.6 Écrire une fonction récursive nub qui, sur la donnée d’une liste l, renvoie la liste sans les doublons. Par exemple, nub [1;1;2;3;1;4] devra retourner [1;2;3;4] ou [2;3;1;4] (selon l’algorithme utilisé). *)

(* 3.7 Refaire les questions précédentes sans utiliser de fonctions récursives. Utiliser pour cela les fonctions du module List, notamment List.map et List.fold_left/List.fold_right. *)
